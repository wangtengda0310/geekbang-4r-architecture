
业务基本场景
<pre>
app、小程序推送秒杀广告 ----> 用户点击广告浏览秒杀商品信息 ----> 小程序端用户下载app ----> 活动开始秒杀抢购商品 ----> 后台审核 ----> 发货
</pre>

> 20个品类*10个商品 = 已经上线100个商品\
> 秒杀通过前端过滤巨大峰值流量，服务端处理一些攻击行为的异常流量\
> 日活100万假设10%参与秒杀，即10万用户参与秒杀\
> 不能超卖\
> 单机房，不能出现系统不可用\
> 微信小程序可以看到秒杀广告，通过引导下载App参与秒杀活动，假设有10%的用户下载App参与秒杀活动\
> 秒杀提前一周预热

#### 总体架构思路

##### 复杂度分析
- 可扩展性复杂度\
  支持上架新的秒杀商品 秒杀流量经过客户端随机算法过滤后到达服务器，服务器再将少量请求打散到1~2秒用户可容忍的范围内\
  用户浏览秒杀商品读取缓存静态页面 假设100万用户10%参加秒杀，早上1小时、中午1小时、晚上4小时访问秒杀商品，10万用户/7天/21600秒=0.67qps\
  用户参与秒杀活动 假设100万用户10%参加秒杀 客户端使用算法过滤1%的流量，即10万个用户中只有1000个用户会真正参与秒杀，两秒时间处理完tps=500
- 高性能、高可用复杂度\
  多级缓存处理浏览秒杀商品的请求
  负载均衡保证秒杀服务的高可用
  熔断、限流、降级防止客户端算法失效或者攻击行为
- 安全性复杂度\
  不能超卖 使用分布式锁实现

已有系统已经上架100个商品并支持着100万日活，考虑为秒杀活动单独搭建一套系统，不影响已有系统的正常运行，使用nginx、redis可满足需求，放弃cdn以节省成本。

浏览秒杀商品
秒杀活动提前一周预热将商品信息加载到各级缓存，nginx使用openresty直接访问redis，总共在客户端、nginx、redis使用三层缓存
<pre>
+------------+    +------------------------------+    +-----------------+     +--------+
| client缓存 | -> | 两台nginx作为入口缓存静态页面 | -> | redis(主备)缓存 | <-> | server |
+------------+    +------------------------------+    +-----------------+     +--------+
                                |                                                 ^
                                + --------------- redis缓存空值避免缓存穿透 ------ +
</pre>

秒杀请求
主要通过客户端随机算法屏蔽大量峰值流量，因此tps可以控制在很低的范围，但是用户浏览商品信息和秒杀活动的时候，会有大量的流量，通过缓存处理这些流量。
<pre>
+----------------+    +-----------+    +-----------------------+    +---------------+    +-------+    +----------+
| client随机算法 | -> | nginx限流 | -> | server降级、熔断、限流 | -> | redis分布式锁 | -> | mysql | -> | 人工审核 |
+----------------+    +-----------+    +-----------------------+    +---------------+    +-------+    +----------+
</pre>
<pre>
+-----------------------+    +--------------------------------------+    +-----------------------------------+    +-----------+    +-----------+
| client内置sdk负载均衡 | -> | 两台nginx带状态检测的轮询算法负载均衡 | -> | 两台server以任务分配的方式接收请求 | -> | redis主备 | -> | mysql主备 |
+-----------------------+    +--------------------------------------+    +-----------------------------------+    +-----------+    +-----------+
</pre>

#### 存储架构设计
客户端app内缓存, 服务进程内缓存，Redis缓存
<pre>
          app缓存
          /\
         /  \  放弃cdn以节省成本
        v    v
   +--静态页面缓存--+        +---------------+
   | nginx    nginx | -----> | server server | server控制秒杀活动商品信息的缓存数据同步
   +----------------+        +---------------+
      |\      /|           /
      | \    / |         /
      |    X   |       /
      |  /   \ |     /
      v v    v v    v
  +-----------------+
  | redis    redis  | redis缓存空值避免缓存穿透
  +-----------------+  
</pre>
#### 计算架构设计
客户端随机算法控制秒杀流量
网关入口根据ip限制重复流量
Redis分布式锁控制最终秒杀到商品的用户
<pre>
          app
          /\
         /  \  随机算法过滤流量
单机房  v    v
   +----------------+
   | nginx    nginx |
   +------限流------+
          / \
         /   \
        v     v
   +--------------------+
   |  server server     |                +------------------------+
   | 限流 熔断 服务降级 | -- 分布式锁 --> | redis <- 主从 -> redis |
   +--------------------+                +------------------------+
           /  .
          /    .
         v      v
+------------------------+
| mysql <- 主备 -> mysql |  ----> 人工审核
+------------------------+
</pre>
<pre>
          app
          /\
         /  \  内置sdk
单机房  v    v
   +----------------+
   | nginx    nginx |
   +----------------+        
          / \
         /   \  带状态检测轮询算法
        v     v
   +-----------------+       +------------------------+
   |  server server  | ----> | redis <- 主从 -> redis |
   +-----------------+       +------------------------+
           /  .
          /    .
         v      v
+------------------------+
| mysql <- 主备 -> mysql |  
+------------------------+
</pre>
#### 其他架构设计
100万访问使用nginx做负载均衡就可以，量起来之后可以换lvs做负载均衡
